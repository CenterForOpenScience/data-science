---
title: "projects_multiple_OSFproducts"
output: html_document
---

This analysis is collecting initial data on the number of projects that take advantage of two of the major behaviors on the OSF that also represent different different points in the workflow: sharing files and registrations. The initial analysis does not take into account when these behaviors happen in relation to each other (e.g. are files uploaded to the project/modified after the registration or only before?), but that may be included as a more complicated relationship in later analyses. 

Data caveats and explanations:

* The data used for the analyses below goes through 4/8/19. 
* 'Sharing a file' is measured by looking for non-registered nodes that are public and have a file in them. It includes files from OSFstorage and all add-ons. If any node in a project is public and has a file in it, the top-level project is counted as sharing a file, even if the top-level itself is private. The registration does not have to be on or include the node that is sharing a file, it just has to be on a node within the same project.
* Only non-spam non-deleted projects/nodes are counted, and only non-withdrawn, non-deleted registrations are counted (excluding old private registrations). Registrations can be under embargo though and still be counted.
* Supplemental preprint nodes are include as 'projects' for this analysis.
* Linked nodes are not included in this initial analysis. So, if a project is public has no files in it, but does have a linked node that is public and has a file in it, the project would not be counted as having a public file. 

```{sql, eval = FALSE, echo = FALSE}

/* query that generates data that gets pulled in; not connected to the DB directly, but here for record keeping */
WITH existing_files AS (SELECT COUNT(*) AS num_files, target_object_id, MIN(created) AS first_osf_file_created, MAX(created) AS last_osf_file_created
						FROM osf_basefilenode
						WHERE type NOT LIKE '%folder%' AND provider LIKE 'osfstorage' AND osf_basefilenode.deleted_on IS NULL AND osf_basefilenode.target_content_type_id = 30
						GROUP BY target_object_id),
	addon_connections AS (SELECT is_public, is_deleted, spam_status, type, osf_abstractnode.id, root_id, osf_abstractnode.created AS node_created, 
											  bitbucket.repo AS bitbucket_repo, bitbucket.created AS bitbucket_created, bitbucket.modified AS bitbucket_modified, 
											  box.folder_name AS box_folder, box.created AS box_created, box.modified AS box_modified,
											  dataverse.dataset AS dataverse_dataset, dataverse.created AS dataverse_created, dataverse.modified AS dataverse_modified,
											  dropbox.folder AS dropbox_folder, dropbox.created AS dropbox_created, dropbox.modified AS dropbox_modified,
											  figshare.folder_name AS figshare_folder, figshare.created AS figshare_created, figshare.modified AS figshare_modified,
											  github.repo AS github_repo, github.created AS github_created, github.modified AS github_modified,
											  gitlab.repo AS gitlab_repo, gitlab.created AS gitlab_created, gitlab.modified AS gitlab_modified,
											  googledrive.folder_path AS googledrive_folderpath, googledrive.created AS googledrive_created, googledrive.modified AS googledrive_modified,
											  onedrive.folder_path AS onedrive_folderpath, onedrive.created AS onedrive_created, onedrive.modified AS onedrive_modified,
											  owncloud.folder_id AS owncloud_folderid, owncloud.created AS owncloud_created, owncloud.modified AS owncloud_modified,
											  s3.folder_name AS s3_foldername, s3.created AS s3_created, s3.modified AS s3_modified
						FROM osf_abstractnode
						LEFT JOIN (SELECT created, modified, owner_id, repo
										FROM addons_bitbucket_nodesettings
										WHERE deleted IS FALSE AND repo IS NOT NULL) bitbucket
						ON osf_abstractnode.id = bitbucket.owner_id
						LEFT JOIN (SELECT folder_name, owner_id, created, modified
										FROM addons_box_nodesettings
										WHERE deleted IS FALSE AND folder_name IS NOT NULL) box
						ON osf_abstractnode.id = box.owner_id
						LEFT JOIN (SELECT dataverse, dataset, created, modified, owner_id
										FROM addons_dataverse_nodesettings
										WHERE deleted IS FALSE AND dataset IS NOT NULL) dataverse
						ON osf_abstractnode.id = dataverse.owner_id
						LEFT JOIN (SELECT folder, owner_id, created, modified
										FROM addons_dropbox_nodesettings
										WHERE deleted IS FALSE AND folder IS NOT NULL) dropbox
						ON osf_abstractnode.id = dropbox.owner_id
						LEFT JOIN (SELECT folder_name, owner_id, created, modified
										FROM addons_figshare_nodesettings
										WHERE deleted IS FALSE AND folder_name IS NOT NULL) figshare
						ON osf_abstractnode.id = figshare.owner_id
						LEFT JOIN (SELECT repo, owner_id, created, modified
										FROM addons_github_nodesettings
										WHERE deleted IS FALSE AND repo IS NOT NULL) github
						ON osf_abstractnode.id = github.owner_id
						LEFT JOIN (SELECT repo, owner_id, created, modified
										FROM addons_gitlab_nodesettings
										WHERE deleted IS FALSE AND repo IS NOT NULL) gitlab
						ON osf_abstractnode.id = gitlab.owner_id
						LEFT JOIN (SELECT folder_path, owner_id, created, modified
										FROM addons_googledrive_nodesettings
										WHERE deleted IS FALSE AND folder_path IS NOT NULL) googledrive
						ON osf_abstractnode.id = googledrive.owner_id
						LEFT JOIN (SELECT folder_path, owner_id, created, modified
										FROM addons_onedrive_nodesettings
										WHERE deleted IS FALSE AND folder_path IS NOT NULL) onedrive
						ON osf_abstractnode.id = onedrive.owner_id
						LEFT JOIN (SELECT folder_id, owner_id, created, modified
										FROM addons_owncloud_nodesettings
										WHERE deleted IS FALSE AND folder_id IS NOT NULL) owncloud
						ON osf_abstractnode.id = owncloud.owner_id
						LEFT JOIN (SELECT folder_name, owner_id, created, modified
										FROM addons_s3_nodesettings
										WHERE deleted IS FALSE AND folder_name IS NOT NULL) s3
						ON osf_abstractnode.id = s3.owner_id),
	registered_projects AS (SELECT DISTINCT ON (osf_abstractnode.root_id) osf_abstractnode.id, type, registered_date, root_id, is_public, is_deleted, date_retracted, embargo_id, osf_embargo.state, registered_from_id
													FROM osf_abstractnode
													LEFT JOIN osf_retraction
													ON osf_abstractnode.retraction_id = osf_retraction.id
													LEFT JOIN osf_embargo
													ON osf_abstractnode.embargo_id = osf_embargo.id
													WHERE type LIKE 'osf.registration' AND is_deleted IS FALSE AND (spam_status = 4 OR spam_status IS NULL) AND date_retracted IS NULL AND (is_public IS TRUE OR embargo_id IS NOT NULL)),
	 files_and_registrations AS (SELECT addon_connections.id AS node_id, addon_connections.root_id, COALESCE(num_files, 0) AS number_files, addon_connections.is_public, node_created, registered_projects.registered_date AS registration_date, first_osf_file_created, last_osf_file_created,
	    						(SELECT count(*) from (values (bitbucket_repo), (box_folder), (dataverse_dataset), (dropbox_folder), (figshare_folder), (github_repo), (gitlab_repo), (googledrive_folderpath), (onedrive_folderpath), (owncloud_folderid), (s3_foldername)) as v(col) WHERE v.col is not null) AS addons_on_node
						FROM addon_connections
						LEFT JOIN existing_files
						ON addon_connections.id = existing_files.target_object_id
						LEFT JOIN registered_projects
						ON addon_connections.id = registered_projects.registered_from_id
						WHERE addon_connections.type LIKE 'osf.node' AND addon_connections.is_deleted IS FALSE AND (addon_connections.spam_status = 4 OR addon_connections.spam_status IS NULL))

Select *
	FROM files_and_registrations;
```

```{r warning=FALSE, echo=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
library(scales)
library(googledrive)
library(kableExtra)

knitr::opts_chunk$set(fig.width=12, fig.height=8) 

data_projects <- read_csv('/Users/courtneysoderberg/Downloads/projects_multiple_OSFproducts.csv')
```

```{r echo = FALSE}
sharing_and_registered <- data_projects %>%
                            group_by(root_id) %>%
                            mutate(has_file = case_when(any(number_files > 0 | addons_on_node > 0) ~ 1, TRUE ~ 0)) %>%
                            mutate(shared_file = case_when(any((number_files > 0 | addons_on_node > 0) & is_public > 0) ~ 1, TRUE ~ 0)) %>%
                            mutate(registered = case_when(any(!is.na(registration_date)) ~ 1, TRUE ~ 0)) %>%
                            summarize(has_file = max(has_file), shared_file = max(shared_file), registered = max(registered), first_registered = min(registration_date), last_registered = max(registration_date), project_created = min(node_created), earliest_osf_file = min(first_osf_file_created),
                                      latest_osf_file = max(last_osf_file_created)) %>%
                            mutate(products = case_when(has_file > 0 & shared_file == 0 & registered == 0 ~ 'OSF_privatefiles_only',
                                                          shared_file ==1 & registered == 0 ~ 'OSF_sharingfiles_only',
                                                          shared_file == 0 & registered ==1 ~ 'Registrations_only',
                                                          shared_file == 1 & registered == 1 ~ 'OSF_sharingfiles_and_registrations',
                                                          shared_file == 0 & registered == 0 ~ 'None')) %>%
                            mutate(pc_by_day = as_date(project_created))
```

The table below shows the number of projects that have each of the actions. These numbers are not mutually exclusive. So, if a project shares a file and has a registration, it will count towards all three totals.

```{r echo = FALSE}
aggregate_data <- sharing_and_registered %>%
                    summarize(`Projects with files` = sum(has_file > 0),
                              `Projects sharing > 0 files` = sum(shared_file > 0), 
                              `Projects with > 0 registrations` = sum(registered > 0),
                              `Projects sharing > 0 files and registered` = sum(shared_file > 0 & registered > 0)) %>%
                    gather() %>%
                    mutate(percentage_total_project = round((value/141313)*100,2), percentage_public_projects = ifelse(key != 'Projects with > 0 registrations' & key != 'Projects with files', round((value/56937)*100,2), NA))
                                                                                                                          
kable(aggregate_data,
  col.names = c('Project actions', 'Number of top-level projects', 'Percentage of top-level projects', 'Percentage of top-level projects with at least 1 public node')) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
  
sharing_projects <- sharing_and_registered %>% filter(shared_file == 1) %>% nrow()
registered_projects <- sharing_and_registered %>% filter(registered == 1) %>% nrow()
sharing_registered <- sharing_and_registered %>% filter(shared_file ==1 & registered ==1) %>% nrow()

```

The graph shows the number of top-level projects that were created each month that either *only* share files, *only* have a registration, do both of these things, are private and have files but no registration, or do none of these things. So, these numbers are mutually exclusive and will not exactly match the number in the table above, which are not mutually exclusive.

```{r echo = FALSE}

 graph <- ggplot(sharing_and_registered, aes(pc_by_day, color = products)) + 
  geom_freqpoly(binwidth = 30) +
  xlab('When projects were created') +
  ylab('Number of Top Level Projects') +
  scale_x_date(breaks = date_breaks("3 month"), labels = date_format("%b %y"))
 
 graph + theme(axis.text.x  = element_text(angle=45,hjust = 1,vjust = 1))
 
```

Potential Next Steps for more complex relationships:

* Are files that are eventually shared being added/modified before or after registrations?
* Add linked projects to the analyses
* How many of the 4817 projects that share files and are registered have contributors in common (i.e. are these projects by a diverse group of people or a smaller set of users who doing this repeatedly across projects)?
* What are the projects with no files in them doing? A lot of them will be empty preprint supplemental nodes, the majority left over from NPD but many newly created supplemental nodes are also left empty. But, not all of them will be supplemental nodes, so what *is* in those projects?
